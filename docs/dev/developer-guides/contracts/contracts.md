# 合约部署

为了保持与 L1 相同的安全性，zkSync 运营者必须在以太坊链上发布其部署的每个合约的合约代码。如果有多个使用相同代码部署的合约，那么它只会发布一次。

虽然第一次部署合同可能相对昂贵，但多次部署相同代码的合约的工厂(factory，即可以部署其他合约的合约)，与 L1 相比，可以节省大量的费用。

这些特性让通过 zkEVM 部署智能合约的过程遵循一个主要规则：_在部署合约之前，运营者应该知道合约的代码_。这意味着只能通过 `EIP712` 交易的方式部署合约，其中 `factory_deps` 字段中包含所提供的字节码。有关 EIP712 交易的更多信息，请通过[这里](../../../api/api.md#eip712)了解。

概要：

- **如何在以太坊上部署合约**
- 
  用户将一个交易发送到零地址(`0x000…000`)用于部署合约，交易的 `data` 字段等于连接到构造函数参数的合约字节码。

- **如何在 zkSync 上部署合约**
- 
  要部署合约，用户调用 [ContractDeployer](./system-contracts.md#contractdeployer) 的 `create` 函数并提供要发布的合约的哈希值以及构造函数参数。合约字节码在 EIP712 交易的“factory_deps”字段中提供。如果合约是一个工厂（即它可以部署其他合约），这些合约的字节码也应该包含在 `factory_deps` 中。

[Hardhat-zksync-deploy](../../../api/hardhat) 插件负责合约部署过程。这里有一个[关于如何使用它的指南](../../../api/hardhat/getting-started.md)。

## Solidity/Vyper 支持

将 Solidity 编译成 zkEVM 字节码需要一个特殊的编译器。目前支持 Solidity `>=0.4.10` 版本，尽管我们强烈建议使用`^0.8.0`作为最稳定的版本。Vyper `^0.3.3`也是支持的。


尽管支持旧版本的 Solidity，但在 zkSync 中，它们有一些限制：
- 不支持 Contract-local 递归。
- 不支持内部函数指针。

如需使用 Solidity 或 Vyper 编译智能合约，可在这里查找相应的[ Hardhat 插件](../../../api/hardhat/plugins.md)。

以太坊加密的原语，如 `ecrecover`，`keccak256` 和 `sha256` 支持预编译。您不需要任何操作，因为所有对预编译的调用都是由编译器在底层完成的。

## `CREATE` 行为的差异

为了便于支持账户抽象，对于每个账户，我们将 nonce 分为两个部分: _deployment nonce_ 与 _transaction nonce_。Deployment nonce 是账户使用 `CREATE` 操作码部署的智能合约数量，而 transaction nonce 用于对交易的重放攻击保护。

这意味着对于智能合约来说，zkSync 上的 nonce 与以太坊上的行为相同，但对于 EOAs 来说，计算部署合约的地址就不那么简单了。在以太坊上，它可以安全地计算为 `hash(RLP[address, nonce])`，而在 zkSync 上，建议等待合约部署完成，并使用新部署的合约地址抓取活动。这些都是由 SDK 在底层完成的。
要获得一个确定的地址，您应该使用 `create2` 来创建合约。它也可以用于 EOAs，但在 SDK 中尚不可用。

## 关于 `factory deps` 的注意事项


一些用法的例子:
最明显的一个例子是，在部署合约时，需要在 `factory deps` 字段中提供它的代码。
- 在 zkSync 上，工厂不存储它们依赖项的字节码，即它们可以部署的合约。它们只存储哈希值。这就是为什么您需要在 `factory_deps` 字段中包含*所有*依赖的字节码。

在底层逻辑中，zkSync存储的不是合同的字节码，而是其字节码的[特殊格式化](#format-of-bytecode-hash)哈希值。你可以看到，即使是[ContractDeployer](./system-contracts.md#contractdeployer)系统合同也接受部署合同的字节码哈希值，而不是它的字节码。然而，为了使合约部署成功，运营商需要知道字节码。正是由于这个原因，交易的`factory_deps`（即工厂依赖）字段被使用：它包含了操作员应该知道的字节码，以便这个交易成功。一旦交易成功，这些字节码将被公布在L1上，并被视为永远被操作者 "知道"。

这两个例子已经通过我们的 [ Hardhat 插件](../../../api/hardhat/plugins.md)在底层无缝完成。

请注意，factory_deps 不一定必须以某种方式由交易调用。这些只是标记，表明这些字节码应该和这个交易一起发布到 L1 上。如果您的合约包含许多不同的工厂依赖项并且它们不适合单个 L1 区块，您可以在多个交易之间拆分工厂依赖项的列表。

例如，如果您想部署合约 `A`，它也可以部署合约 `B` 和 `C`。这意味着您将有三个工厂依赖项来部署交易：`A`、`B` 和 `C`。如果发布它们所需的 pubdata 太大，无法放入同一个区块中，您可以发送一个只包含工厂依赖项 `A` 和 `B` 的虚拟交易(假设它们的总长度足够小)，并使用第二个交易进行实际部署，同时提供合约 `C` 的字节码作为工厂依赖项。注意，如果某个合约*本身*大于每个区块允许的限制，则必须将该合约拆分为更小的合约。

### L1->L2 通信

提交 L1->L2 交易的[接口](https://github.com/matter-labs/v2-testnet-contracts/blob/d4a2869ab6feadb396f357e55aa41d137adc0ab0/l1/contracts/zksync/interfaces/IMailbox.sol#L76)接受这个特定交易所需的所有工厂依赖项的列表。处理它们的逻辑与处理 L2 交易的逻辑相同。唯一的区别是，由于用户已经在 L1 上发布了字节码的完整映像，所以不需要在 L1 上再次发布这些字节码。  

### 字节码哈希值的格式

每个 zkEVM 字节码必须符合以下格式:

- 其长度必须能被 32 整除。
- 它的长度（32 字节块）应该是奇数。换句话说，`bytecodeLength % 64 == 32`。
- 它不能长于 `2^16`32 字节的字，也就是 `2^21` 字节。

zkSync 合约字节码的 32 字节哈希值计算方法如下:

- 前两个字节表示字节码哈希值格式的版本，目前等于 `[1,0]`。
- 第二个 2 字节表示字节码的长度，以 32 字节为单位。
- 其余 28 字节（即 28 个低位大端序字节）等于 `sha256` 合约字节码哈希值的最后 28 个字节。
